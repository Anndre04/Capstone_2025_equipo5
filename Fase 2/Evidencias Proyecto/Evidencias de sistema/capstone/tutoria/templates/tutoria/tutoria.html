{% extends "base.html" %}
{% load static %}

{% block title %}Tutor√≠a{% endblock %}

{% block content %}

{% if tutoria and tutoria.estado == "En curso" %}
<div class="container-fluid">
    <p id="status" class="mt-2 fw-bold text-warning">Iniciando...</p>

    <div class="row g-4" id="videocallSection">
        
        <div class="col-12 col-lg-8">
            <div class="card border-0 shadow-sm h-100 video-card">
                <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Videollamada</h5>
                </div>
                
                <div class="card-body p-0 position-relative video-body-container">
                    
                    <div id="remoteVideoWrapper" class="w-100 h-100 bg-dark bg-opacity-10 d-flex align-items-center justify-content-center main-video-wrapper">
                        <video id="remoteVideo" autoplay playsinline class="w-100 h-100 main-video" style="object-fit: contain;"></video>
                        <div id="waitingMessage" class="text-center text-muted py-2">
                            Esperando a que el otro usuario se conecte...
                        </div>


                        <div id="videoControls" class="position-absolute bottom-0 start-50 translate-middle-x p-2 mb-3 rounded-pill shadow-lg bg-dark bg-opacity-75 d-flex gap-3">
        
                            <button class="btn btn-sm btn-light" id="btnToggleMic" title="Silenciar"><i class="bi bi-mic-fill"></i></button>
                            <button class="btn btn-sm btn-light" id="btnToggleCam" title="C√°mara On/Off"><i class="bi bi-camera-video-fill"></i></button>
                            
                            <!-- Se a√±adi√≥ el texto "Compartir" para una mejor UX -->
                            <button class="btn btn-sm btn-secondary" id="btnShareScreen" title="Compartir Pantalla">
                                <i class="bi bi-display-fill me-1"></i> Compartir
                            </button>
                            
                            <button class="btn btn-sm btn-danger" id="btnEndCall" title="Colgar"><i class="bi bi-telephone-fill"></i></button>
                            
                            <button class="btn btn-sm btn-light" id="btnToggleFullscreen" title="Pantalla Completa">
                                <i class="bi bi-arrows-fullscreen"></i>
                            </button>

                        </div>
                
                    </div>

                    <div id="localVideoContainer" class="position-absolute bottom-0 end-0 m-3 z-1 shadow-lg border border-3 border-primary rounded" style="width: 200px; height: 120px; background: #000;">
                        <video id="localVideo" autoplay muted playsinline class="w-100 h-100 rounded" style="object-fit: cover;"></video>
                        <div class="position-absolute bottom-0 start-0 bg-dark bg-opacity-75 text-white px-1 py-0 small rounded-top-end">
                            T√∫
                        </div>
                    </div>
                </div>
            </div>
            <div id="tutoriaActions" class="d-flex flex-column flex-sm-row gap-3 mt-3" style="display: none;">
                <button 
                    id="btnSubirDocumento"
                    type="button"
                    class="btn btn-success btn-lg shadow-sm"
                    data-bs-toggle="modal"
                    data-bs-target="#uploadDocumentModal"
                    style="display:none">
                    <i class="bi bi-file-earmark-arrow-up-fill me-2"></i> Subir Documento
                </button>
                <button 
                    id="btnRealizarEvaluacion"
                    type="button"
                    class="btn btn-primary btn-lg shadow-sm"
                    data-bs-toggle="modal"
                    data-bs-target="#crearEvaluacionModal"
                    style="display:none">
                    <i class="bi bi-clipboard-check-fill me-2"></i> Realizar Evaluaci√≥n
                </button>
            </div>
        </div>
        <div class="col-12 col-lg-4">
        <div class="card border-0 shadow-sm h-100 chat-card">
            <div class="card-header bg-secondary text-white">
                <h5 class="mb-0">Chat</h5>
            </div>

            <div class="card-body p-0 d-flex flex-column">

                <!-- CONTENEDOR PARA chat.js (metadatos) -->
                <div 
                    id="chat-container"
                    data-user="{{ request.user.id }}"
                    data-chat-id="{{ chat_id }}"
                ></div>

                <!-- MENSAJES DEL CHAT -->
                <div id="chat-messages" 
                    class="flex-grow-1 p-3"
                    style="height: 300px; overflow-y: auto;">

                    {% for m in mensajes %}
                        <div class="mb-2 {% if m.remitente.id == request.user.id %}text-end{% else %}text-start{% endif %}">
                            
                            <div class="d-inline-block px-3 py-2 rounded-3
                                {% if m.remitente.id == request.user.id %}
                                    bg-primary text-white
                                {% else %}
                                    bg-light border
                                {% endif %}
                            ">
                                {{ m.texto }}
                            </div>

                            <div class="small text-muted mt-1">
                                {{ m.fecha_envio|date:"H:i" }}
                            </div>
                        </div>
                    {% endfor %}
                </div>

                <!-- INPUT DE MENSAJE -->
                <div class="border-top p-3">
                    <form id="message-form" class="d-flex gap-2" action="javascript:void(0)">
                        <input 
                            type="text" 
                            id="message-input" 
                            class="form-control" 
                            placeholder="Escribe un mensaje..."
                        >
                        <button class="btn btn-primary" id="btn-enviar">
                            <i class="bi bi-send-fill"></i>
                        </button>
                    </form>
                </div>

            </div>
        </div>
    </div>
    </div>
</div>

<div class="modal fade" id="uploadDocumentModal" tabindex="-1" aria-labelledby="uploadDocumentModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-0 shadow-lg rounded-3">
            <div class="modal-header bg-success text-white rounded-top-3">
                <h5 class="modal-title" id="uploadDocumentModalLabel">
                    Subir documentos, guias de estudios, etc.
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Cerrar"></button>
            </div>

            <div class="modal-body">
                <form method="POST" action="{% url "tutoria:archivostutoria" tutoria.id %}" enctype="multipart/form-data" id="uploadForm"> 
                    {% csrf_token %} 
                    
                    {# Campo de ID de Tutor√≠a Oculto (Aseg√∫rate de llenarlo con JS si es necesario) #}
                    <input type="hidden" name="tutoria_id" id="tutoriaIdInput" value=""> 

                    <div class="mb-4 border p-3 rounded-3 bg-light">
                        <label for="id_archivo" class="form-label fw-semibold">
                            Seleccionar Archivos para la tutoria (PDF)
                        </label>
                        <input 
                            type="file" 
                            name="archivo" 
                            id="id_archivo" 
                            class="form-control"
                            accept="application/pdf"
                            multiple 
                        >
                        <div class="form-text text-muted">Sube uno o m√°s archivos PDF. Puedes renombrarlos abajo.</div>
                    </div>
                        
                    <div id="archivos-seleccionados-container" class="mt-3">
                        <p class="fw-semibold small mb-1">Archivos adjuntos para nombrar:</p>
                        <ul id="lista-archivos-seleccionados" class="list-group list-group-flush border rounded-3 small">
                            <li class="list-group-item text-muted" id="initial-message">Ning√∫n archivo seleccionado.</li>
                        </ul>
                        <div id="file-error-message" class="text-danger small mt-2 d-none"></div>
                    </div>

                    <div class="modal-footer border-0 pt-4">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                        <button type="submit" class="btn btn-success" id="confirmUploadBtn">Confirmar Subida</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Modal Crear Evaluaci√≥n -->
<div class="modal fade" id="crearEvaluacionModal" tabindex="-1" aria-labelledby="crearEvaluacionLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">

      <form id="crearEvaluacionForm" action="{% url "crearevaluacion" tutoria.id %}" method="post">
        {% csrf_token %}
        <div class="modal-header bg-primary text-white">
          <h5 class="modal-title" id="crearEvaluacionLabel">Crear Evaluaci√≥n</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Cerrar"></button>
        </div>

        <div class="modal-body">
          <!-- T√≠tulo -->
          <div class="mb-3">
            <label for="titulo" class="form-label fw-semibold">T√≠tulo de la Evaluaci√≥n:</label>
            <input type="text" class="form-control" name="titulo" id="tituloEvaluacion">
          </div>

          <!-- Contenedor de preguntas -->
          <div class="container-fluid px-0">
            <div class="d-flex justify-content-between align-items-center mb-3">
              <h5 class="mb-0 fw-bold">Preguntas</h5>
              <button id="btnAgregarPregunta" type="button" class="btn btn-outline-primary btn-sm">
                <i class="bi bi-plus-circle me-1"></i> Agregar Pregunta
              </button>
            </div>
            <div id="preguntasContainer"></div>
            <small class="text-danger d-none" id="errorPreguntas"><i class="bi bi-exclamation-circle-fill"></i>Debe agregar al menos una pregunta.</small>
          </div>
        </div>

        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
          <button type="submit" id="btnenviarEvaluacion" class="btn btn-success">Guardar Evaluaci√≥n</button>
        </div>
      </form>
    </div>
  </div>
</div>

<script src="{% static 'js/chat.js' %}"></script>


<script>
    // --------------------------------------------------------------------------
    // CLASE ENCAPSULADA PARA MANEJAR ARCHIVOS M√öLTIPLES (FileCustomizer)
    // (Esta clase es la misma y funciona como antes)
    // --------------------------------------------------------------------------
    class FileCustomizer {
        // ... (Constructor, updateFiles, renderFileList, updateFileInput, handleRemoveClick
        //      son id√©nticos a la implementaci√≥n anterior) ...
        constructor(fileInputId, listId) {
            this.fileInput = document.getElementById(fileInputId);
            this.listaArchivos = document.getElementById(listId);
            this.errorMessage = document.getElementById('file-error-message');
            
            if (!this.fileInput || !this.listaArchivos) return;

            this.selectedFiles = []; 
            this.fileNames = []; 

            this.listaArchivos.addEventListener('click', this.handleRemoveClick.bind(this));
            this.fileInput.addEventListener('change', this.updateFiles.bind(this));
            
            this.renderFileList();
        }

        updateFiles() {
            const newFiles = Array.from(this.fileInput.files);
            this.selectedFiles = newFiles;
            this.fileNames = new Array(newFiles.length).fill(null); 
            this.renderFileList();
        }
        
        renderFileList() {
            this.listaArchivos.innerHTML = '';
            this.errorMessage.classList.add('d-none');

            if (this.selectedFiles.length === 0) {
                const li = document.createElement('li');
                li.className = 'list-group-item text-muted';
                li.textContent = 'Ning√∫n archivo seleccionado.';
                this.listaArchivos.appendChild(li);
                return;
            }

            this.selectedFiles.forEach((file, index) => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex align-items-center justify-content-between p-2';

                // Creaci√≥n de elementos...
                const fileInfoContainer = document.createElement('div');
                fileInfoContainer.className = 'd-flex align-items-center flex-grow-1';
                
                const removeButton = document.createElement('button');
                removeButton.type = 'button';
                removeButton.className = 'btn btn-sm btn-outline-danger me-2 p-1';
                removeButton.innerHTML = '<i class="bi bi-x"></i>';
                removeButton.setAttribute('data-index', index);
                removeButton.title = 'Eliminar este archivo';
                removeButton.dataset.action = 'remove-file'; 
                
                const filenameSpan = document.createElement('span');
                filenameSpan.className = 'fw-medium text-truncate small me-3';
                filenameSpan.textContent = file.name;

                fileInfoContainer.appendChild(removeButton);
                fileInfoContainer.appendChild(filenameSpan);

                const inputName = document.createElement('input');
                inputName.type = 'text';
                inputName.name = `nombre_archivo_${index}`; 
                inputName.placeholder = 'Nombre para guardar (sin extensi√≥n)';
                inputName.className = 'form-control form-control-sm w-50';
                inputName.maxLength = 80;
                
                const initialName = file.name.substring(0, file.name.lastIndexOf('.')) || file.name;
                inputName.value = this.fileNames[index] || initialName;
                
                inputName.addEventListener('input', (e) => {
                    this.fileNames[index] = e.target.value;
                });
                
                li.appendChild(fileInfoContainer);
                li.appendChild(inputName);
                this.listaArchivos.appendChild(li);
            });

            this.updateFileInput();
        }
        
        updateFileInput() {
            try {
                const dataTransfer = new DataTransfer();
                this.selectedFiles.forEach(file => {
                    dataTransfer.items.add(file);
                });
                this.fileInput.files = dataTransfer.files;
            } catch (e) {
                this.errorMessage.textContent = 'Tu navegador no soporta la edici√≥n de la lista de archivos.';
                this.errorMessage.classList.remove('d-none');
            }
        }

        handleRemoveClick(event) {
            const removeButton = event.target.closest('[data-index]');
            if (removeButton && removeButton.dataset.action === 'remove-file') {
                event.preventDefault(); 
                const index = parseInt(removeButton.dataset.index);
                
                if (index >= 0 && index < this.selectedFiles.length) {
                    this.selectedFiles.splice(index, 1);
                    this.fileNames.splice(index, 1);
                    this.renderFileList();
                }
            }
        }

        // Nuevo m√©todo para obtener todos los datos, incluidos los nombres personalizados
        getFormData() {
            const formData = new FormData();

            // 1. Agregar los archivos reales del input (ya actualizados por updateFileInput)
            const files = this.fileInput.files;
            for (let i = 0; i < files.length; i++) {
                formData.append('archivo', files[i]);
            }

            // 2. Agregar los nombres personalizados
            this.fileNames.forEach((name, index) => {
                if (name !== null) {
                    formData.append(`nombre_archivo_${index}`, name);
                } else if (files[index]) {
                    // Si el nombre es null, usar el nombre original (sin extensi√≥n) como fallback
                    const originalName = files[index].name.substring(0, files[index].name.lastIndexOf('.')) || files[index].name;
                    formData.append(`nombre_archivo_${index}`, originalName);
                }
            });

            return formData;
        }
    }


    // --------------------------------------------------------------------------
    // L√ìGICA DE SUBIDA AJAX Y MANEJO DE MODAL
    // --------------------------------------------------------------------------

    const uploadDocumentModal = document.getElementById('uploadDocumentModal');
    const formElement = document.getElementById('uploadForm');
    const tutoriaIdInput = document.getElementById('tutoriaIdInput');
    const confirmUploadBtn = document.getElementById('confirmUploadBtn');
    
    // Instancia del manejador de archivos (CR√çTICO)
    const fileCustomizer = new FileCustomizer('id_archivo', 'lista-archivos-seleccionados');

    /**
     * Funci√≥n que maneja el env√≠o AJAX del formulario.
     */
    async function handleFormSubmit(event) {
        event.preventDefault(); // Detener la recarga de la p√°gina

        const url = formElement.action;
        const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;

        // 1. Deshabilitar bot√≥n y mostrar carga
        confirmUploadBtn.disabled = true;
        confirmUploadBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Subiendo...';

        // 2. Obtener los datos del formulario (archivos, nombres, y tutoria_id)
        const formData = fileCustomizer.getFormData();
        formData.append('tutoria_id', tutoriaIdInput.value); // A√±adir el ID de la tutor√≠a

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': csrftoken,
                    // NO establecer Content-Type; el navegador lo hace autom√°ticamente
                    // para FormData, incluyendo el boundary.
                },
                body: formData
            });

            const data = await response.json(); // Asumimos que Django devuelve JSON

            if (response.ok) {
                // √âxito: Mostrar mensaje y recargar la lista de archivos (si aplica)
                
                // üí° NOTA: messages.success de Django no funciona en AJAX.
                // Usamos un alert o una librer√≠a como Toastr/SweetAlert.
                alert(`‚úÖ √âxito: ${data.message || 'Archivos subidos correctamente.'}`);

                // Cerrar modal y posiblemente recargar la secci√≥n de la p√°gina
                const modal = bootstrap.Modal.getInstance(uploadDocumentModal);
                modal.hide();

                // üîÑ Recargar la ventana o el componente de lista de archivos de la tutor√≠a
                window.location.reload(); 

            } else {
                // Fallo del servidor (4xx, 5xx)
                alert(`‚ùå Error al subir: ${data.error || 'Ocurri√≥ un error inesperado en el servidor.'}`);
                console.error('Server error data:', data);
            }

        } catch (error) {
            // Fallo de red o error de JS
            alert('‚ùå Error de conexi√≥n: No se pudo contactar al servidor.');
            console.error('Fetch error:', error);
        } finally {
            // 3. Habilitar bot√≥n
            confirmUploadBtn.disabled = false;
            confirmUploadBtn.innerHTML = 'Confirmar Subida';
        }
    }

    // 4. Conectar el listener del formulario
    formElement.addEventListener('submit', handleFormSubmit);


    // 5. L√ìGICA DE INYECCI√ìN DE ID AL ABRIR EL MODAL (Como en el c√≥digo anterior)
    uploadDocumentModal.addEventListener('show.bs.modal', event => {
        const button = event.relatedTarget; 
        const tutoriaId = button.getAttribute('data-tutoria-id');
        const tutoriaUrl = button.getAttribute('data-tutoria-url');

        if (tutoriaIdInput) { tutoriaIdInput.value = tutoriaId || ''; }
        if (formElement && tutoriaUrl) { formElement.action = tutoriaUrl; }

        // Resetear el estado del FileCustomizer al abrir
        fileCustomizer.selectedFiles = [];
        fileCustomizer.fileNames = [];
        fileCustomizer.updateFileInput(); 
        fileCustomizer.renderFileList();   
    });

</script>

<script>

let preguntaCount = 0;

// ==============================
// Funci√≥n de validaci√≥n
// ==============================
function validarEvaluacion() {
    console.log("üìå Iniciando validaci√≥n...");

    let valido = true;
    const preguntas = document.querySelectorAll("#preguntasContainer .card");
    const errorPreguntas = document.getElementById("errorPreguntas");

    // Ocultar errores anteriores
    document.querySelectorAll(".text-danger").forEach(e => e.classList.add("d-none"));
    document.querySelectorAll(".is-invalid").forEach(e => e.classList.remove("is-invalid"));

    // 1Ô∏è‚É£ T√≠tulo no vac√≠o
    const titulo = document.getElementById("tituloEvaluacion");
    if (!titulo.value.trim()) {
        marcarError(titulo, "El t√≠tulo de la evaluaci√≥n es obligatorio.");
        valido = false;
    }

    // 2Ô∏è‚É£ Al menos una pregunta
    if (preguntas.length === 0) {
        console.log("‚ùå No hay preguntas");
        if (errorPreguntas) errorPreguntas.classList.remove("d-none");
        valido = false;
    }

    // 3Ô∏è‚É£ Validar cada pregunta
    preguntas.forEach((pregunta, index) => {
        const inputPregunta = pregunta.querySelector("input[type='text']:not([name*='_opcion_'])");
        const inputPuntos = pregunta.querySelector("input[type='number']");
        const opciones = pregunta.querySelectorAll(".input-group");

        // Contenido de pregunta
        if (!inputPregunta.value.trim()) {
            marcarError(inputPregunta, "La pregunta no puede estar vac√≠a.");
            valido = false;
            return;
        }

        // Puntos v√°lidos
        if (!inputPuntos.value || parseInt(inputPuntos.value) <= 0) {
            marcarError(inputPuntos, "Los puntos deben ser mayores que 0.");
            valido = false;
            return;
        }

        // Al menos 2 opciones
        if (opciones.length < 2) {
            marcarError(pregunta, "La pregunta debe tener al menos 2 opciones.");
            valido = false;
            return;
        }

        // Opciones no vac√≠as
        const inputVacio = Array.from(opciones).find(op => !op.querySelector("input[type='text']").value.trim());
        if (inputVacio) {
            marcarError(inputVacio.querySelector("input[type='text']"), "Hay una opci√≥n vac√≠a.");
            valido = false;
            return;
        }

        // Opci√≥n correcta seleccionada
        const correcta = pregunta.querySelector("input[type='radio']:checked");
        if (!correcta) {
            marcarError(pregunta, "Debe marcar una opci√≥n correcta.");
            valido = false;
            return;
        }
    });

    return valido; // ‚úÖ Devuelve true si todo est√° bien
}

// ==============================
// Funci√≥n para enviar AJAX
// ==============================
function enviarEvaluacion() {
    const form = document.getElementById("crearEvaluacionForm");

    if (!validarEvaluacion()) {
        console.log("‚ùå Validaci√≥n fallida, no se env√≠a el formulario");
        return;
    }

    console.log("‚úÖ Validaci√≥n correcta, enviando AJAX...");

    const formData = new FormData(form);

    fetch(form.action, {
        method: 'POST',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRFToken': form.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        console.log("üì¶ Respuesta del servidor:", data);

        if (data.status === 'success') {
            window.showAlert(data.message, 'success');

            // Reset formulario y modal
            form.reset();
            document.getElementById("preguntasContainer").innerHTML = '';
            preguntaCount = 0;

            const modalEl = document.getElementById("crearEvaluacionModal");
            const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
            modal.hide();
        } else {
            window.showAlert(data.message || 'Ocurri√≥ un error', 'error');
        }
    })
    .catch(error => {
        window.showAlert('Hubo un error en su solicitud', 'error');
    });
}

// ==============================
// Funci√≥n para mostrar errores
// ==============================
function marcarError(elemento, mensaje) {
    let small = elemento.parentElement.querySelector(".text-danger");

    if (!small) {
        small = document.createElement("small");
        small.className = "text-danger d-flex align-items-center gap-1 mt-1";
        small.innerHTML = `<i class="bi bi-exclamation-circle-fill"></i> ${mensaje}`;
        elemento.parentElement.appendChild(small);
    } else {
        small.innerHTML = `<i class="bi bi-exclamation-circle-fill"></i> ${mensaje}`;
    }

    small.classList.remove("d-none");
    elemento.classList.add("is-invalid");
    elemento.scrollIntoView({ behavior: "smooth", block: "center" });
    elemento.focus();
}

document.getElementById("btnenviarEvaluacion").addEventListener("click", function(e) {
  e.preventDefault();
  enviarEvaluacion();
});

document.getElementById("btnAgregarPregunta").addEventListener("click", function(e) {
  e.preventDefault();
  agregarPregunta();
});

function agregarPregunta() {
  preguntaCount++;
  const preguntaId = preguntaCount;

  const divPregunta = document.createElement("div");
  divPregunta.classList.add("card", "mb-3", "p-3");
  divPregunta.dataset.id = preguntaId;

  divPregunta.innerHTML = `
    <div class="d-flex justify-content-between align-items-center mb-2">
        <h5 class="mb-0">Pregunta ${preguntaId}</h5>
        <button type="button" class="btn btn-danger btn-sm" onclick="eliminarPregunta(${preguntaId})">
        <i class="bi bi-trash"></i> Eliminar Pregunta
        </button>
    </div>

    <input type="text" name="pregunta_${preguntaId}" class="form-control mb-2" placeholder="Texto de la pregunta">

    <input type="number" name="pregunta_${preguntaId}_puntos" class="form-control mb-2" min="1" placeholder="Puntos de la pregunta">

    <div id="opcionesContainer_${preguntaId}"></div>

    <button type="button" class="btn btn-outline-primary btn-sm" onclick="agregarOpcion(${preguntaId})">
        <i class="bi bi-plus-circle"></i> Agregar Opci√≥n
    </button>
    `;

  document.getElementById("preguntasContainer").appendChild(divPregunta);

  // Agrega dos opciones iniciales
  setTimeout(() => {
    agregarOpcion(preguntaId);
    agregarOpcion(preguntaId);
  }, 50);
}

function agregarOpcion(preguntaId) {
  const contenedorOpciones = document.getElementById(`opcionesContainer_${preguntaId}`);
  if (!contenedorOpciones) return;

  const opcionCount = contenedorOpciones.querySelectorAll(".input-group").length + 1;

  const divOpcion = document.createElement("div");
  divOpcion.classList.add("input-group", "mb-2");
  divOpcion.innerHTML = `
    <div class="input-group-text">
      <input type="radio" name="pregunta_${preguntaId}_correcta" value="${opcionCount}" required>
    </div>
    <input type="text" name="pregunta_${preguntaId}_opcion_${opcionCount}" class="form-control" placeholder="Opci√≥n ${opcionCount}" required>
    <button class="btn btn-outline-danger" type="button" onclick="eliminarOpcion(${preguntaId}, this)">
      <i class="bi bi-x-circle"></i>
    </button>
  `;

  contenedorOpciones.appendChild(divOpcion);
}

function eliminarPregunta(preguntaId) {
  const pregunta = document.querySelector(`[data-id="${preguntaId}"]`);
  if (pregunta) pregunta.remove();
  reindexarPreguntas();
}

function eliminarOpcion(preguntaId, boton) {
  boton.closest(".input-group").remove();
  reindexarOpciones(preguntaId);
}

function reindexarPreguntas() {
  const preguntas = document.querySelectorAll("#preguntasContainer .card");
  preguntas.forEach((pregunta, index) => {
    const nuevoId = index + 1;
    pregunta.dataset.id = nuevoId;
    pregunta.querySelector("h5").textContent = `Pregunta ${nuevoId}`;
    pregunta.querySelector("input[type='text']").name = `pregunta_${nuevoId}`;

    const eliminarBtn = pregunta.querySelector(".btn-danger");
    eliminarBtn.setAttribute("onclick", `eliminarPregunta(${nuevoId})`);

    const opcionesContainer = pregunta.querySelector(`[id^="opcionesContainer_"]`);
    opcionesContainer.id = `opcionesContainer_${nuevoId}`;

    const agregarBtn = pregunta.querySelector(".btn-outline-primary");
    agregarBtn.setAttribute("onclick", `agregarOpcion(${nuevoId})`);

    reindexarOpciones(nuevoId);
  });
  preguntaCount = preguntas.length;
}

function reindexarOpciones(preguntaId) {
  const contenedorOpciones = document.getElementById(`opcionesContainer_${preguntaId}`);
  if (!contenedorOpciones) return;

  const opciones = contenedorOpciones.querySelectorAll(".input-group");
  opciones.forEach((opcion, index) => {
    const nuevoIndex = index + 1;
    const radio = opcion.querySelector("input[type='radio']");
    const texto = opcion.querySelector("input[type='text']");
    radio.name = `pregunta_${preguntaId}_correcta`;
    radio.value = nuevoIndex;
    texto.name = `pregunta_${preguntaId}_opcion_${nuevoIndex}`;
    texto.placeholder = `Opci√≥n ${nuevoIndex}`;
  });
}
</script>



<canvas id="recordingCanvas" style="display:none;"></canvas>

<style>
.toast-container {
    z-index: 9999;
    display: flex;
    flex-direction: column-reverse; /* üëà Apila los toasts de abajo hacia arriba */
    gap: 10px;
}
/* CSS para corregir el tama√±o del video en PC y mejorar la visualizaci√≥n */
.video-card, .chat-card {
    height: 100%;
    /* CLAVE: M√°xima altura para la vista de escritorio (lg+), ajusta el aspecto */
    max-height: 500px; /* Incrementado ligeramente para mejor aspecto */
}
.video-body-container {
    height: 100%; /* Asegura que el contenedor interno ocupe todo el espacio */
}
.main-video-wrapper {
    height: 100%;
}
.main-video {
    /* object-fit: contain asegura que el video remoto completo se vea sin recorte */
    object-fit: contain !important; 
}

/* Ajuste de Responsive para m√≥viles */
@media (max-width: 991.98px) {
    /* Usamos 70vh para dejar espacio para la barra de navegaci√≥n y otros elementos */
    .video-card, .chat-card {
        max-height: 70vh; 
    }
    .chat-card {
        height: 70vh; /* Asegurar que la tarjeta de chat use la altura completa en m√≥viles */
    }
}

/* Estilos de Fullscreen */
#remoteVideoWrapper:-webkit-full-screen {
    width: 100% !important;
    height: 100% !important;
    background: #000;
}
#remoteVideoWrapper:fullscreen {
    width: 100% !important;
    height: 100% !important;
    background: #000;
}
</style>

<script>
// --- Variables de configuraci√≥n de Django y WS ---
const TUTORIA_ID = "{{ tutoria.id }}";
const USER_ID = "{{ request.user.id }}";
const ROLE = sessionStorage.getItem('rol_actual');

// 2. Variables del DOM (Declaradas con 'let' para ser asignadas en DOMContentLoaded)
let actionsContainer;
let btnSubirDocumento;
let btnRealizarEvaluacion; 
let btnResponderEvaluacion;

function updateActionButtonsVisibility() {
    if (!ROLE) {
        console.warn("‚ö†Ô∏è No se encontr√≥ la variable ROLE.");
        if (actionsContainer) actionsContainer.style.display = 'none';
        return;
    }

    if (actionsContainer) {
        if (ROLE === 'Tutor') {
            actionsContainer.style.display = 'flex';
            
            // Mostrar botones de Tutor
            if (btnSubirDocumento) btnSubirDocumento.style.display = 'inline-block';
            if (btnRealizarEvaluacion) btnRealizarEvaluacion.style.display = 'inline-block';

            // Ocultar bot√≥n de Estudiante
            if (btnResponderEvaluacion) btnResponderEvaluacion.style.display = 'none';

        } 
        else if (ROLE === 'Estudiante') {
            
            // üí° IMPORTANTE: Si la evaluaci√≥n es publicada din√°micamente, el btnResponderEvaluacion
            // debe ser visible AHORA. El c√≥digo del WebSocket se encarga de cambiar su display.
            
            // Mostrar solo bot√≥n de Responder (si fue renderizado por Django o por WebSocket)
            if (btnResponderEvaluacion && btnResponderEvaluacion.style.display !== 'none') {
                actionsContainer.style.display = 'flex';
            } else {
                // Si el estudiante no tiene botones visibles, ocultar el contenedor.
                actionsContainer.style.display = 'none';
            }

            // Ocultar botones de Tutor
            if (btnSubirDocumento) btnSubirDocumento.style.display = 'none';
            if (btnRealizarEvaluacion) btnRealizarEvaluacion.style.display = 'none'; 

        } 
        else {
            actionsContainer.style.display = 'none';
        }
    }
}

function showResponseButtonDynamically(evaluacionId) {
    if (ROLE !== 'Estudiante') return;

    // üîπ Crear el bot√≥n si no existe
    if (!btnResponderEvaluacion) {
        btnResponderEvaluacion = document.createElement('a');
        btnResponderEvaluacion.id = 'btnResponderEvaluacion';
        btnResponderEvaluacion.className = 'btn btn-primary btn-lg shadow-sm';
        btnResponderEvaluacion.target = '_blank';
        btnResponderEvaluacion.innerHTML = '<i class="bi bi-file-earmark-text-fill me-2"></i> Responder Evaluaci√≥n';
        if (actionsContainer) actionsContainer.appendChild(btnResponderEvaluacion);
    }

    // üîπ Actualizar URL y mostrar bot√≥n
    const urlBase = "{% url 'responder_evaluacion' '00000000-0000-0000-0000-000000000000' %}";
    btnResponderEvaluacion.href = urlBase.replace('00000000-0000-0000-0000-000000000000', evaluacionId);
    btnResponderEvaluacion.style.display = 'inline-block';
    if (actionsContainer) actionsContainer.style.display = 'flex';

    console.log(`‚úÖ Evaluaci√≥n ${evaluacionId} publicada. Bot√≥n habilitado.`);
}


// --- CONFIGURACI√ìN DE CONEXI√ìN ---
console.log("CONFIG: TUTORIA_ID:", TUTORIA_ID, "USER_ID:", USER_ID, "ROLE:", ROLE);
if (!TUTORIA_ID || TUTORIA_ID.includes('tutoria.id')) {
    console.error("CONFIG ERROR: TUTORIA_ID no est√° correctamente interpolado por Django.");
}

const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
const wsPath = `${wsScheme}://${window.location.host}/ws/tutoria/${TUTORIA_ID}/`;
console.log("CONFIG: WebSocket Path:", wsPath); 

// --- ESTADO GLOBAL AJUSTADO: Usamos el gestor en lugar del socket directo ---
let wsManager;

// --- Estado de la Sesi√≥n ---
let localStream = null; 
let peerConnection;
let screenStream;
let pendingIceCandidates = []; 
let remoteAudioTrack;
let remoteVideoTrack; 
let isScreenSharing = false;
let isRemoteSharing = false;
let p2pReconnectTimeout;
let dataChannel; // DataChannel se mantiene: hook para futuras integraciones

// --- Referencias al DOM ---
// Nota: pueden ser null si el script se ejecuta antes de renderizar el DOM.
// En acciones posteriores siempre verificamos existencia (if (elem) ...).
const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");
const statusEl = document.getElementById("status");
const waitingMessage = document.getElementById("waitingMessage");

// Botones de control
const btnToggleMic = document.getElementById("btnToggleMic");
const btnToggleCam = document.getElementById("btnToggleCam");
const btnEndCall = document.getElementById("btnEndCall");
const btnShareScreen = document.getElementById("btnShareScreen");
const btnToggleFullscreen = document.getElementById("btnToggleFullscreen");
const remoteVideoWrapper = document.getElementById("remoteVideoWrapper"); // Necesario para fullscreen

// Chat DOM elements (se mantienen en DOM pero NO tendr√°n l√≥gica interna aqu√≠)
const chatInput = document.getElementById("chatInput");
const btnSendMessage = document.getElementById("btnSendMessage");
const chatMessages = document.getElementById("chatMessages");

// ICE servers
const configuration = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

// =========================================================
// GESTOR DE WEBSOCKET ROBUSTO (CLASE)
// =========================================================

// --- CONSTANTES DE CONEXI√ìN Y RECONEXI√ìN ---
const MAX_RECONNECT_ATTEMPTS = 15; // L√≠mite de intentos de reconexi√≥n
const INITIAL_RECONNECT_DELAY = 1000; // 1 segundo de retraso inicial
const MAX_RECONNECT_DELAY = 30000; // M√°ximo 30 segundos de retraso

// --- CONSTANTES DE HEARTBEAT ---
const HEARTBEAT_INTERVAL = 30000; // Enviar un PING cada 30 segundos
const HEARTBEAT_TIMEOUT = 5000;   // Esperar PONG por 5 segundos

class TutoriaWebsocketManager {
    constructor(url, messageHandler) {
        this.url = url;
        this.messageHandler = messageHandler;

        this.socket = null;
        this.reconnectAttempts = 0;
        this.isConnected = false;
        this.isUserClosing = false;
        
        this.pingTimer = null;
        this.pongTimeout = null;
    }

    connect() {
        if (this.socket) {
            // Asegura que la conexi√≥n anterior se cierre antes de crear una nueva
            this.socket.onclose = null; 
            this.socket.close(); 
        }

        console.log(`[WS] Intentando conectar a ${this.url}`);
        this.socket = new WebSocket(this.url);
        this.isUserClosing = false; // Reset al intentar conectar

        this.socket.onopen = this.onOpen.bind(this);
        this.socket.onmessage = this.onMessage.bind(this);
        this.socket.onclose = this.onClose.bind(this);
        this.socket.onerror = this.onError.bind(this);
    }

    onOpen() {
        console.log(`[WS] Conectado exitosamente. Intentos de reconexi√≥n: ${this.reconnectAttempts}`);
        this.isConnected = true;
        
        if (this.reconnectAttempts > 0) {
            // Notificar a la aplicaci√≥n principal que se reanud√≥ la conexi√≥n P2P
            this.messageHandler({ type: 'reconnect_success' });
        }
        
        this.reconnectAttempts = 0; // Resetear contador al tener √©xito
        if (statusEl) statusEl.textContent = "WebSocket Conectado. Enviando join...";
        
        // Iniciar el Heartbeat
        this.startHeartbeat();

        // Enviar el mensaje de JOIN despu√©s de conectar/reconectar
        this.send({ type: "join", user_id: USER_ID, role: ROLE });
    }

    onClose(event) {
        this.isConnected = false;
        this.stopHeartbeat(); // Detener Heartbeat al cerrar
        
        if (this.isUserClosing) {
            console.log("[WS] Desconexi√≥n limpia iniciada por el usuario (C√≥digo 1000).");
            return;
        }

        console.warn(`[WS] Conexi√≥n cerrada. C√≥digo: ${event.code}.`);
        
        if (this.reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            this.reconnectAttempts++;
            
            // F√≥rmula de Exponential Backoff
            let delay = INITIAL_RECONNECT_DELAY * Math.pow(2, this.reconnectAttempts);
            delay = Math.min(delay, MAX_RECONNECT_DELAY);
            
            console.log(`[WS] Reintentando en ${delay / 1000}s (Intento #${this.reconnectAttempts})...`);
            if (statusEl) { statusEl.textContent = `Reconectando WebSocket... Intento #${this.reconnectAttempts} üîÑ`; statusEl.style.color = "orange"; }
            
            setTimeout(() => {
                this.connect();
            }, delay);
        } else {
            console.error("[WS] L√≠mite de reconexi√≥n alcanzado. Conexi√≥n fallida permanente.");
            this.messageHandler({type: 'connection_failed_permanent'});
        }
    }

    onError(error) {
        console.error("[WS] Error de WebSocket:", error);
    }

    // --- Heartbeat Logic ---
    startHeartbeat() {
        if (this.pingTimer) clearInterval(this.pingTimer);
        this.pingTimer = setInterval(() => {
            this.send({ type: 'ping' });
            if (this.pongTimeout) clearTimeout(this.pongTimeout);
            this.pongTimeout = setTimeout(() => {
                // Si el PONG no llega a tiempo, forzar cierre para iniciar la reconexi√≥n
                console.warn("[WS] Heartbeat fallido (no se recibi√≥ PONG). Forzando desconexi√≥n.");
                // Forzar el cierre inicia el proceso de reconexi√≥n en onClose()
                if (this.socket) this.socket.close(); 
            }, HEARTBEAT_TIMEOUT);
        }, HEARTBEAT_INTERVAL);
    }

    stopHeartbeat() {
        if (this.pingTimer) {
            clearInterval(this.pingTimer);
            this.pingTimer = null;
        }
        if (this.pongTimeout) {
            clearTimeout(this.pongTimeout);
            this.pongTimeout = null;
        }
    }

    onMessage(event) {
        try {
            const data = JSON.parse(event.data);

            if (data.type === 'pong') {
                // Recibido el PONG, limpiar el timeout
                clearTimeout(this.pongTimeout);
                this.pongTimeout = null;
                return;
            }
            
            // Reenv√≠a todos los dem√°s mensajes al manejador principal de la aplicaci√≥n
            this.messageHandler(data);

        } catch (e) {
            console.error("[WS] Error al procesar mensaje JSON:", e);
        }
    }

    // --- M√©todos P√∫blicos ---
    close() {
        this.isUserClosing = true;
        this.stopHeartbeat();
        if (this.socket) {
            this.socket.close(1000, "User ended call"); // Cierre limpio
        }
    }
    
    send(data) {
        if (this.isConnected && this.socket.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify(data));
        } else {
            console.warn(`[WS] Intento de env√≠o fallido: WebSocket no est√° abierto. Mensaje: ${data.type}`);
        }
    }
}

// =========================================================
// 1. INICIALIZACI√ìN DE DISPOSITIVOS
// =========================================================

/**
 * Intenta obtener media de forma flexible, primero audio, luego video.
 */
async function initMedia(timeoutMs = 1500) {
    console.log("LOG: Iniciando acceso flexible a media..."); 
    const newStream = new MediaStream();
    let audioReady = false;
    let videoReady = false;

    // Funci√≥n helper para obtener media con timeout
    async function tryGetMedia(constraints) {
        try {
            return await Promise.race([
                navigator.mediaDevices.getUserMedia(constraints),
                new Promise((_, reject) => setTimeout(() => reject("timeout"), timeoutMs))
            ]);
        } catch (err) {
            return null;
        }
    }

    // --- 1. Micr√≥fono ---
    const audioStream = await tryGetMedia({ audio: true, video: false });
    if (audioStream && audioStream.getAudioTracks().length > 0) {
        newStream.addTrack(audioStream.getAudioTracks()[0]);
        audioReady = true;
        console.log("LOG: Micr√≥fono (Audio) obtenido OK.");
    } else {
        console.warn("LOG WARNING: No se pudo obtener micr√≥fono.");
        if (btnToggleMic) {
            btnToggleMic.disabled = true;
            btnToggleMic.classList.replace('btn-light', 'btn-danger');
        }
    }

    // --- 2. C√°mara ---
    const videoStream = await tryGetMedia({ audio: false, video: true });
    if (videoStream && videoStream.getVideoTracks().length > 0) {
        newStream.addTrack(videoStream.getVideoTracks()[0]);
        videoReady = true;
        console.log("LOG: C√°mara (Video) obtenida OK.");
    } else {
        console.warn("LOG WARNING: No se pudo obtener c√°mara.");
        if (btnToggleCam) {
            btnToggleCam.disabled = true;
            btnToggleCam.classList.replace('btn-light', 'btn-danger');
        }
    }

    // --- 3. Finalizaci√≥n ---
    if (audioReady || videoReady) {
        localStream = newStream;
        if (localVideo) localVideo.srcObject = localStream;
        console.log("LOG: Acceso a media OK. Tracks obtenidos:", localStream.getTracks().length); 
        if (statusEl) { statusEl.textContent = "Media local lista. Conectando..."; statusEl.style.color = "blue"; }
    } else {
        localStream = null;
        console.warn("LOG WARNING: Ning√∫n dispositivo de media disponible.");
        if (statusEl) { statusEl.textContent = "Conectando sin c√°mara ni micr√≥fono‚Ä¶"; statusEl.style.color = "orange"; }
        if (btnToggleMic) btnToggleMic.disabled = true;
        if (btnToggleCam) btnToggleCam.disabled = true;
        if (btnShareScreen) btnShareScreen.disabled = true;
    }

    // HOOK: habilitar inputs de chat (se mantienen en DOM, pero no funcionales aqu√≠).
    if (chatInput) chatInput.disabled = false;
    if (btnSendMessage) btnSendMessage.disabled = false;
}

// =========================================================
// 2. L√ìGICA DE CONEXI√ìN WEBRTC (P2P)
// =========================================================
let audioSender;
let videoSender;

function createPeerConnection() {
    console.log("LOG: Creando nueva RTCPeerConnection."); 
    
    if (peerConnection && peerConnection.connectionState !== "closed") {
        console.log("LOG: PeerConnection ya existe, abortando creaci√≥n.");
        return;
    }
    if (peerConnection) peerConnection.close(); 
    
    peerConnection = new RTCPeerConnection(configuration);

    attachP2PUnloadGuard(peerConnection);
    
    // --- DataChannel Setup ---
    // NOTA: mantenemos la creaci√≥n del DataChannel para que no rompa P2P ni features futuras,
    // pero NO implementamos l√≥gica de chat aqu√≠. Para integrar el chat general, usa el hook
    // initChatGeneral() o window.handleDataChannelMessage en el futuro.
    if (ROLE === "Tutor") {
        dataChannel = peerConnection.createDataChannel("chat");
        setupDataChannel(dataChannel);
    } else {
        peerConnection.ondatachannel = (event) => {
            dataChannel = event.channel;
            setupDataChannel(dataChannel);
        };
    }
    
    // 2. A√ëADIR TRACKS LOCALES Y GUARDAR SENDERS
    if (localStream && localStream.getTracks().length > 0) {
        localStream.getTracks().forEach(track => {
            if (track.kind === 'video') {
                videoSender = peerConnection.addTrack(track, localStream);
                console.log("LOG: Video track a√±adido al PeerConnection.");
            } else if (track.kind === 'audio') {
                audioSender = peerConnection.addTrack(track, localStream);
                console.log("LOG: Audio track a√±adido al PeerConnection.");
            }
        });
    } else {
        console.log("LOG: localStream es nulo/vac√≠o. Conexi√≥n P2P sin media inicial.");
    }
    
    // 3. Recibir tracks remotos
    peerConnection.ontrack = e => {
        console.log("LOG: Track remoto recibido:", e.track.kind); 
        // Compatibilidad: algunos browsers no rellenan e.streams
        const remoteStream = (e.streams && e.streams[0]) || new MediaStream([e.track]);
        if (remoteVideo) remoteVideo.srcObject = remoteStream;
        if (waitingMessage) waitingMessage.classList.add("d-none"); 
        
        if (e.track.kind === 'audio') {
            remoteAudioTrack = e.track;
        } else if (e.track.kind === 'video') {
            remoteVideoTrack = e.track;
        }
    };

    // 4. ICE y Negociaci√≥n
    peerConnection.onicecandidate = event => {
        if (event.candidate && wsManager && wsManager.isConnected) {
            wsManager.send({ type: "ice-candidate", candidate: event.candidate });
        }
    };

    peerConnection.onnegotiationneeded = async () => {
        console.log("LOG: Negociaci√≥n necesaria. Enviando nueva oferta.");
        if (ROLE === "Tutor" && wsManager && wsManager.isConnected) { 
            try {
                const offer = await peerConnection.createOffer({ iceRestart: true }); 
                await peerConnection.setLocalDescription(offer);
                wsManager.send({ type: "offer", sdp: offer }); 
                console.log("LOG: Oferta de renegociaci√≥n enviada.");
            } catch (err) {
                console.error("LOG ERROR: Error al crear oferta en negociaci√≥n:", err);
            }
        }
    };

    // 5. Monitoreo de estado
    peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        console.log("LOG: PeerConnection State:", state); 
        
        if (state === "disconnected" || state === "failed") {
            if (statusEl) { statusEl.textContent = "Desconexi√≥n P2P. Reintentando... üîÑ"; statusEl.style.color = "orange"; }
            if (ROLE === "Tutor" && wsManager && wsManager.isConnected) { 
                if (p2pReconnectTimeout) clearTimeout(p2pReconnectTimeout);
                p2pReconnectTimeout = setTimeout(() => {
                    console.log("LOG: Forzando renegociaci√≥n ICE...");
                    try {
                        if (peerConnection && peerConnection.signalingState !== 'closed') {
                           peerConnection.restartIce();
                        } 
                    } catch (e) {
                        console.warn("Error al forzar restartIce:", e);
                    }
                }, 5000); 
            }
        } else if (state === "connected") {
            if (statusEl) { statusEl.textContent = "Conectado ‚úÖ"; statusEl.style.color = "green"; }
            if (p2pReconnectTimeout) clearTimeout(p2pReconnectTimeout);
        }
    };
}

// =========================================================
// 3. L√ìGICA DE DATA CHANNEL (NO-CHAT / HOOKS)
// =========================================================

function setupDataChannel(channel) {
    dataChannel = channel;
    console.log("LOG: DataChannel establecido (sin l√≥gica de chat por defecto).");
    
    dataChannel.onopen = () => {
        console.log("LOG: DataChannel abierto.");
        // HOOK: si quieres notificar UI sobre el canal abierto, implementa:
        // window.onDataChannelOpen && window.onDataChannelOpen();
    };

    dataChannel.onclose = () => {
        console.warn("LOG WARNING: DataChannel cerrado.");
        // HOOK: window.onDataChannelClose && window.onDataChannelClose();
    };

    // Mensajes entrantes por DataChannel: **no procesamos como chat interno**.
    // Devolveremos el payload a un handler global si existe (para integraciones futuras).
    dataChannel.onmessage = (event) => {
        try {
            const payload = JSON.parse(event.data);
            console.log("LOG: Mensaje recibido por DataChannel (payload):", payload);
            // HOOK: si implementas una funci√≥n global para manejar mensajes DC:
            if (typeof window.handleDataChannelMessage === 'function') {
                window.handleDataChannelMessage(payload);
            }
            // No mostramos mensajes en UI aqu√≠ (chat se manejar√° por el chat general).
        } catch (err) {
            console.warn("LOG WARNING: Mensaje DC no JSON o error al parsear:", err);
        }
    };
}

// Fullscreen helper (sin cambios)
function toggleFullscreen() {
    const isFullscreen = document.fullscreenElement;
    const icon = btnToggleFullscreen ? btnToggleFullscreen.querySelector('i') : null;

    if (!isFullscreen) {
        if (remoteVideoWrapper && remoteVideoWrapper.requestFullscreen) {
            remoteVideoWrapper.requestFullscreen();
        } else if (remoteVideoWrapper && remoteVideoWrapper.webkitRequestFullscreen) { /* Safari */
            remoteVideoWrapper.webkitRequestFullscreen();
        } else if (remoteVideoWrapper && remoteVideoWrapper.msRequestFullscreen) { /* IE11 */
            remoteVideoWrapper.msRequestFullscreen();
        }
        if (icon) { icon.classList.remove('bi-arrows-fullscreen'); icon.classList.add('bi-fullscreen-exit'); }
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
        if (icon) { icon.classList.remove('bi-fullscreen-exit'); icon.classList.add('bi-arrows-fullscreen'); }
    }
}

// Placeholder no-op appendMessage (mantener hook; NO muestra nada)
function appendMessage(/* message, sender */) {
    // NO-OP: el chat se gestiona con el chat general externo.
    // Si quieres ver logs para debugging, descomenta:
    // console.log("appendMessage() llamado pero chat local est√° desactivado.");
}

// sendMessage ahora es un stub que muestra c√≥mo conectar el chat general
function sendMessage() {
    // NO-OP: aqu√≠ no enviamos al DataChannel como chat interno.
    // Si quieres que el bot√≥n de enviar invoque el chat general, implementa:
    // window.sendChatGeneral && window.sendChatGeneral(chatInput.value);
    console.warn("sendMessage() llamado pero chat local est√° desactivado. Usa tu chat general.");
}

// =========================================================
// 4. SE√ëALIZACI√ìN (WEBSOCKETS) Y AUXILIARES
// =========================================================

async function handleWebsocketMessage(data) {
    console.log("LOG: Mensaje WS recibido:", data.type); 

    try {
        switch (data.type) {
            case "reset_connection":
                console.log("LOG: Usuario remoto se reconect√≥, reiniciando PeerConnection.");
                if (peerConnection) peerConnection.close();
                createPeerConnection();
                // Notifica al usuario que recarg√≥ para que haga offer
                if (wsManager && wsManager.isConnected) wsManager.send({ type: "reconnect_success" });
                break;

            case "reconnect_success":
                console.log("LOG: Reconexi√≥n de WS exitosa. Forzando renegociaci√≥n P2P.");
                if (peerConnection && peerConnection.connectionState !== "closed" && ROLE === "Tutor") {
                    try {
                        await peerConnection.setLocalDescription(
                             await peerConnection.createOffer({ iceRestart: true })
                        );
                        if (wsManager && wsManager.isConnected) wsManager.send({ type: "offer", sdp: peerConnection.localDescription.sdp });
                    } catch (err) {
                        console.error("Error forzando renegociaci√≥n:", err);
                    }
                }
                break;
            
            case "connection_failed_permanent":
                endCall(true);
                if (statusEl) { statusEl.textContent = "Error: Conexi√≥n perdida permanentemente. üõë"; statusEl.style.color = "red"; }
                break;

            case "user_joined":
                if (!peerConnection || peerConnection.connectionState === "closed") {
                    createPeerConnection();
                    if (ROLE === "Tutor") {
                        console.log("LOG: Tutor enviando Offer inicial.");
                        try {
                            const offer = await peerConnection.createOffer();
                            await peerConnection.setLocalDescription(offer);
                            if (wsManager && wsManager.isConnected) wsManager.send({ type: "offer", sdp: offer.sdp });
                        } catch (err) {
                            console.error("Error creando offer al unirse usuario:", err);
                        }
                    }
                }
                break;

            case "offer":
                console.log("LOG: Recibida Offer. Enviando Answer.");
                if (!peerConnection || peerConnection.connectionState === "closed") createPeerConnection();
                
                try {
                    await peerConnection.setRemoteDescription({ type: "offer", sdp: data.sdp });
                    await flushPendingIceCandidates();
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    if (wsManager && wsManager.isConnected) wsManager.send({ type: "answer", sdp: answer.sdp });
                } catch (err) {
                    console.error("Error procesando offer:", err);
                }
                break;

            case "answer":
                console.log("LOG: Recibida Answer.");
                if (!peerConnection || peerConnection.connectionState === "closed") createPeerConnection();
                
                try {
                    await peerConnection.setRemoteDescription({ type: "answer", sdp: data.sdp });
                    await flushPendingIceCandidates();
                } catch (err) {
                    console.error("Error procesando answer:", err);
                }
                break;

            case "ice-candidate":
                if (!data.candidate) break;
                if (!peerConnection || peerConnection.remoteDescription === null) {
                    pendingIceCandidates.push(data.candidate);
                } else {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    } catch (err) {
                        console.warn("LOG WARNING: Error al a√±adir ICE candidate:", err);
                    }
                }
                break;

            case "screen_share_start":
                if (data.user_id !== USER_ID) {
                    isRemoteSharing = true;
                    if (statusEl) { statusEl.textContent = "El otro usuario est√° compartiendo su pantalla. üñ•Ô∏è"; statusEl.style.color = "blue"; }
                    if (btnShareScreen) btnShareScreen.disabled = true;
                }
                break;

            case "screen_share_stop":
                if (data.user_id !== USER_ID) {
                    isRemoteSharing = false;
                    if (statusEl) { statusEl.textContent = "Conectado ‚úÖ"; statusEl.style.color = "green"; }
                    if (btnShareScreen) btnShareScreen.disabled = false;
                }
                break;

            case "user_left":
                console.log("LOG: Usuario remoto sali√≥.");
                if (remoteVideo) remoteVideo.srcObject = null;
                remoteVideoTrack = null;
                remoteAudioTrack = null;
                if (statusEl) { statusEl.textContent = "El otro usuario sali√≥ ‚ùå"; statusEl.style.color = "red"; }
                if (waitingMessage) waitingMessage.classList.remove("d-none");
                break;

            case "evaluacion_publicada":
                if (typeof showResponseButtonDynamically === 'function' && ROLE === 'Estudiante') {
                    showResponseButtonDynamically(data.evaluacion_id);
                }
                break;

            // Nota: No procesamos 'chat_message' localmente; el chat general debe usar su propio WS/consumer.
        }
    } catch (err) {
        console.error("LOG ERROR: Error manejando mensaje WS:", err, data);
    }
}

function enableUnloadProtection() {
    window.onbeforeunload = (e) => {
        e.preventDefault();
        e.returnValue = "";
    };
}

function disableUnloadProtection() {
    window.onbeforeunload = null;
}

// Activar / desactivar seg√∫n estado real del WebRTC
function attachP2PUnloadGuard(pc) {
    pc.addEventListener("connectionstatechange", () => {
        const state = pc.connectionState;
        console.log("LOG: Estado P2P:", state);

        if (state === "connected" || state === "connecting") {
            enableUnloadProtection();
        } else {
            disableUnloadProtection();
        }
    });
}

/**
 * Inicializa el Gestor de WebSocket y conecta.
 */
function connectWebSocket() {
    wsManager = new TutoriaWebsocketManager(wsPath, handleWebsocketMessage);
    wsManager.connect();
}

async function flushPendingIceCandidates() {
    if (!peerConnection || !pendingIceCandidates.length) return;
    console.log(`LOG: A√±adiendo ${pendingIceCandidates.length} ICE candidates pendientes.`);
    while (pendingIceCandidates.length) {
        const candidate = pendingIceCandidates.shift();
        try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (err) {
            console.warn("LOG WARNING: Error al a√±adir pending candidate:", err, candidate);
        }
    }
}

// =========================================================
// 5. L√ìGICA DE CONTROLES
// =========================================================
let currentAudioEnabled = true;
let currentVideoEnabled = true;

function toggleTrack(track, button, isAudio) {
    if (!track) return;
    track.enabled = !track.enabled;
    let enabled = track.enabled;
    const icon = button ? button.querySelector('i') : null;

    if (isAudio) {
        currentAudioEnabled = enabled;
        if (icon) { icon.classList.toggle('bi-mic-fill', enabled); icon.classList.toggle('bi-mic-mute-fill', !enabled); }
    } else {
        currentVideoEnabled = enabled;
        if (icon) { icon.classList.toggle('bi-camera-video-fill', enabled); icon.classList.toggle('bi-camera-video-off-fill', !enabled); }
    }

    if (button) {
        button.classList.toggle('btn-light', enabled);
        button.classList.toggle('btn-danger', !enabled);
        button.title = enabled ? (isAudio ? 'Silenciar' : 'C√°mara On/Off') : (isAudio ? 'Activar Mic' : 'C√°mara Off/On');
    }
}

function toggleMic() {
    const audioTrack = localStream ? localStream.getAudioTracks()[0] : null;
    toggleTrack(audioTrack, btnToggleMic, true);
    console.log(`LOG: Micr√≥fono toggled: ${currentAudioEnabled}`);
}

function toggleCam() {
    const videoTrack = localStream ? localStream.getVideoTracks()[0] : null;
    toggleTrack(videoTrack, btnToggleCam, false);
    console.log(`LOG: C√°mara toggled: ${currentVideoEnabled}`);
}

async function startScreenSharing() {
    if (isScreenSharing) return;
    
    if (isRemoteSharing) {
        console.warn("LOG WARNING: El usuario remoto ya est√° compartiendo la pantalla. Espere.");
        if (statusEl) { statusEl.textContent = "El otro usuario est√° compartiendo. Espera tu turno."; statusEl.style.color = "red"; }
        setTimeout(() => {
             if (isRemoteSharing) {
                 if (statusEl) { statusEl.textContent = "El otro usuario est√° compartiendo su pantalla. üñ•Ô∏è"; statusEl.style.color = "blue"; }
             } else {
                 if (statusEl) { statusEl.textContent = "Conectado ‚úÖ"; statusEl.style.color = "green"; }
             }
        }, 5000);
        return; 
    }

    console.log("LOG: Iniciando Screen Sharing...");
    try {
        screenStream = await navigator.mediaDevices.getDisplayMedia({ 
            video: true, 
            audio: true 
        });
        isScreenSharing = true;

        if (wsManager && wsManager.isConnected) wsManager.send({ type: "screen_share_start", user_id: USER_ID });
        
        const screenVideoTrack = screenStream.getVideoTracks()[0];
        const screenAudioTrack = screenStream.getAudioTracks()[0]; // Puede ser undefined
        
        if (videoSender) {
            try { await videoSender.replaceTrack(screenVideoTrack); } catch (e) { console.warn("replaceTrack video failed:", e); }
        } else if (peerConnection && screenVideoTrack) {
            videoSender = peerConnection.addTrack(screenVideoTrack, screenStream);
        }

        if (screenAudioTrack) {
            if (audioSender) {
                try { await audioSender.replaceTrack(screenAudioTrack); } catch (e) { console.warn("replaceTrack audio failed:", e); }
            } else if (peerConnection) {
                audioSender = peerConnection.addTrack(screenAudioTrack, screenStream);
            }
        } else if (audioSender) {
             try { await audioSender.replaceTrack(null); } catch(e) { console.warn("replaceTrack(null) no soportado:", e); }
        }
        
        if (localVideo) localVideo.srcObject = screenStream;
        if (btnShareScreen) { btnShareScreen.classList.remove('btn-secondary'); btnShareScreen.classList.add('btn-warning'); btnShareScreen.innerHTML = '<i class="bi bi-x-circle-fill me-1"></i> Detener'; }
        
        if (screenStream.getVideoTracks()[0]) screenStream.getVideoTracks()[0].onended = stopScreenSharing;

    } catch (err) {
        console.error("LOG ERROR: Fallo al iniciar Screen Sharing:", err);
        isScreenSharing = false; 
    }
}

async function stopScreenSharing() {
    if (!isScreenSharing) return;
    
    if (wsManager && wsManager.isConnected) wsManager.send({ type: "screen_share_stop", user_id: USER_ID });
    console.log("LOG: Enviado screen_share_stop al servidor.");

    if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
        screenStream = null;
    }
    isScreenSharing = false;
    
    const originalVideoTrack = localStream ? localStream.getVideoTracks()[0] : null;
    const originalAudioTrack = localStream ? localStream.getAudioTracks()[0] : null;
    
    if (videoSender && originalVideoTrack) {
        try { await videoSender.replaceTrack(originalVideoTrack); } catch(e){ console.warn("replaceTrack original video failed:", e); }
        if (originalVideoTrack) originalVideoTrack.enabled = currentVideoEnabled; 
    } else if (videoSender) {
        try { await videoSender.replaceTrack(null); } catch(e){ console.warn("replaceTrack(null) video failed:", e); }
    }
    
    if (audioSender && originalAudioTrack) {
        try { await audioSender.replaceTrack(originalAudioTrack); } catch(e){ console.warn("replaceTrack original audio failed:", e); }
        if (originalAudioTrack) originalAudioTrack.enabled = currentAudioEnabled;
    } else if (audioSender) {
        try { await audioSender.replaceTrack(null); } catch(e){ console.warn("replaceTrack(null) audio failed:", e); }
    }

    if (localVideo) localVideo.srcObject = localStream;

    if (btnShareScreen) { btnShareScreen.classList.remove('btn-warning'); btnShareScreen.classList.add('btn-secondary'); btnShareScreen.innerHTML = '<i class="bi bi-display-fill me-1"></i> Compartir'; }
}

function endCall(isExternalFailure = false) {
    console.log(`LOG: Finalizando la llamada (Fallo externo: ${isExternalFailure})...`);
    
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
    }
    if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
        screenStream = null;
    }
    
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }
    
    if (wsManager) {
        wsManager.close();
    }

    if (localVideo) localVideo.srcObject = null;
    if (remoteVideo) remoteVideo.srcObject = null;
    if (!isExternalFailure && statusEl) { statusEl.textContent = "Llamada finalizada üõë"; statusEl.style.color = "red"; }
    
    if (btnEndCall) btnEndCall.disabled = true;
    if (btnToggleCam) btnToggleCam.disabled = true;
    if (btnToggleMic) btnToggleMic.disabled = true;
    if (btnShareScreen) btnShareScreen.disabled = true;
}

// =========================================================
// 6. LISTENERS DE BOTONES E INICIO
// =========================================================
document.addEventListener("DOMContentLoaded", () => {
    console.log("LOG: DOMContentLoaded. Iniciando flujo de aplicaci√≥n.");

    // Asignar referencias a botones de acciones si existen (local scope)
    actionsContainer = document.getElementById('tutoriaActions');
    btnSubirDocumento = document.getElementById('btnSubirDocumento');
    btnRealizarEvaluacion = document.getElementById('btnRealizarEvaluacion'); 
    btnResponderEvaluacion = document.getElementById('btnResponderEvaluacion');

    // --- 6.1. Controles B√°sicos ---
    if (btnToggleMic) btnToggleMic.addEventListener('click', toggleMic);
    if (btnToggleCam) btnToggleCam.addEventListener('click', toggleCam);
    if (btnEndCall) btnEndCall.addEventListener('click', endCall);
    if (btnToggleFullscreen) btnToggleFullscreen.addEventListener('click', toggleFullscreen);
    if (btnShareScreen) btnShareScreen.addEventListener('click', () => {
        if (isScreenSharing) {
            stopScreenSharing();
        } else {
            startScreenSharing();
        }
    });

    // --- 6.5. Inicio de WebRTC ---
    initMedia().then(connectWebSocket);


    // ==========================
    // üí¨ CHAT GENERAL
    // ==========================
    // Verificar que chat.js carg√≥ el m√≥dulo
    if (window.ChatModule) {

        // Obtener la conversaci√≥n actual o la primera
        let chatDefault =
            document.querySelector(".conversation-item.active") ||
            document.querySelector(".conversation-item");

        if (chatDefault) {
            console.log("üí¨ Abriendo chat general desde videollamada...");
            window.ChatModule.openChat(chatDefault);
        } else {
            console.warn("‚ö†Ô∏è No hay conversaciones disponibles para el chat.");
        }

    } else {
        console.warn("‚ö†Ô∏è ChatModule no est√° disponible ‚Äî ¬øcargaste chat.js?");
    }

    console.log("‚úÖ Chat general conectado a la UI de videollamada");
});


</script>

{% else %}
<div class="container mt-5">
    <div class="alert alert-danger" role="alert">
        <h4 class="alert-heading">Tutor√≠a No Disponible</h4>
        <p>La tutor√≠a con ID **{{ tutoria.id }}** no est√° marcada como "En curso" o no existe.</p>
        <hr>
        <p class="mb-0">Por favor, verifique el estado en su panel de control.</p>
    </div>
</div>
{% endif %}
{% endblock %}